#!/bin/env python
"""
Generate a policy stub from a list of CloudTrail Events. This policy can then
be attached to a role and passed to a CICD pipeline. It allows you to use the
"least privileged" principle on you CICD infrastructure pipelines. One short
coming is that it does not scope the policy to the resources, but use a 
wildcard resource instead.
"""
from argparse import ArgumentParser, RawTextHelpFormatter
from os import listdir
from os.path import join, isdir, isfile, basename
import boto3
import gzip
import json
import logging
import re
import uuid
import sys

logging.basicConfig(level=logging.WARN)
logger = logging.getLogger()

s3 = boto3.client('s3')
iam = boto3.client('iam')

valid_actions = re.compile(r"(.*):([^0-9]+)([0-9]{8}.*)?")


def _generate_policy_from_actions(actions):
    """Return a list of actions."""
    unique_actions = list(set(actions))
    short_actions = list(map(lambda a: valid_actions.sub(r"\1:\2", a.replace('.amazonaws.com', '')), unique_actions))
    user_actions = list(filter(lambda a: a not in ("cloudtrail:StartLogging", "cloudtrail:StopLogging"), short_actions))
    sid = str(uuid.uuid4())
    return {
        "Version": "2012-10-17",
        "Statement": [{
            "Sid": f"CloudFormationRoleGenerator-{sid}",
            "Effect": "Allow",
            "Action": list(sorted(user_actions)),
            "Resource": "*"
        }]
    }


def generate_policy(args):
    """Main function."""
    if not isdir(args.logs_dir):
        raise ValueError(f"Invalid '--log-dir' parameter: no such directory {args.logs_dir}")
    onlyfiles = [f for f in listdir(args.logs_dir) if isfile(join(args.logs_dir, f))]
    user_records = []
    user_actions = []
    for f in onlyfiles:
        logger.debug("Processing %s ...", f)
        with gzip.open(join(args.logs_dir, f), "rb") as f:
            records = json.loads(f.read().decode('utf-8'))['Records']
            records = list(filter(lambda r: r.get('userIdentity', {}).get('userName', '') == args.username, records))
            records = list(sorted(records, key=lambda x: x['eventTime']))
            actions = list(map(lambda r: f"{r['eventSource']}:{r['eventName']}", records))
            user_records.extend(records)
            user_actions.extend(actions)

    if args.records_output:
        logger.debug("Writing records to '%s'", args.records_output)
        with open(args.records_output, "w") as records_output:
            json.dump(user_records, records_output, indent=2)

    user_policy = _generate_policy_from_actions(user_actions)
    if args.validate:
        logger.debug("Validating policy ...")
        response = iam.create_policy(
            PolicyName=str(uuid.uuid4()),
            Path='/',
            PolicyDocument=json.dumps(user_policy, indent=2),
            Description=f"Policy Generated by {basename(__file__)}"
        )
        policy_arn = response.get('Policy', {}).get('Arn', None)
        if policy_arn:
            iam.delete_policy(PolicyArn=policy_arn)
        else:
            logger.warning("Failed to create the policy. Check if it is valid")
    if args.policy_output:
        logger.debug("Writing policy to '%s'", args.policy_output)
        with open(args.policy_output, "w") as policy_output:
            json.dump(user_policy, policy_output, indent=2)
    else:
        print(json.dumps(user_policy, indent=2))


def parse_command_line():
    """Parse the command line arguments."""
    parser = ArgumentParser(
        prog='generate_policy',
        description=__doc__,
        formatter_class=RawTextHelpFormatter)
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Run the program in debug mode',
        required=False,
        default=False)
    parser.add_argument(
        '--logs-dir',
        help='The path where the logs were downloaded',
        metavar="DIR",
        required=True)
    parser.add_argument(
        '--username',
        help='The EventUsername used to filter the events. Default to "StackDeveloper"',
        required=False, default='StackDeveloper')
    parser.add_argument(
        '--records-output',
        metavar="FILE",
        help='The name of the file where to store the records',
        required=False)
    parser.add_argument(
        '--policy-output',
        metavar="FILE",
        help='If set, writes the policy to file',
        required=False)
    parser.add_argument(
        '--validate',
        action='store_true',
        help='If set try to validate the Policy by creating a policy in IAM',
        required=False)
    parser.set_defaults(func=generate_policy)
    return parser.parse_args()


def main():
    """Main entrypoint"""
    args = parse_command_line()
    try:
        if args.debug:
            logger.setLevel(level=logging.DEBUG)
        return args.func(args)
    except Exception as e:
        logging.error(e, exc_info=True)
        return 1


if __name__ == '__main__':
    sys.exit(main())
